questions :
- argument str ou pas ?
- gerer les espaces en trop ?
- cas int un seul nb erreur?
- message erreur adapte autorise ?
- si ss, sencée executer sa quand sb impossible ?

correc 
https://github.com/caecitasminimus/school21-checklists

etapes :
algo de tri
--
bonus


ressources interessantes :
https://github.com/AdrianWR/push_swap
https://medium.com/@jamierobertdawson/push-swap-the-least-amount-of-moves-with-two-stacks-d1e76a71789a

radix sort ; attention aux negatifs lors de la lecture binaire
ruby -e "puts (1..100).to_a.shuffle"
ARG="1 2 3" | ./push_swap $=ARG   (ajouter = pour eviter conflits sous zsh)

push b le plus petit nb puis adapter à partir de là
 grps de 3
diviser par deux
ecart min et max
opti en essayant d'utiliser tous les moves


quand push sur b rb si > median

50         9 7coup
100        48 4 
1           
            69 5

ra rb 
rra rrb
ra rrb
rra rb

1 arg ou stack triee affiche rien
8 moves max si 5
3 moves max si 3
<700 pour 100
<5500 pour 500


push tout dans b sauf min max et median
ensuite stocker nb de coup optimal pour trier head de b
comparer nb de coup du nb a trier dans les *nb de coup* prochain next de b
pusha l'opti et trier a en optimisant le nb de coup : 8 ra et 6 rb == 6rr et 2ra 
recommencer

ajouter error dans struct desormais pour faciliter gestion erreur
exit success au lieu de remonter en cas derreur?