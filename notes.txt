questions :
- argument str ou pas ?
- gerer les espaces en trop ?
- cas int un seul nb erreur?
- message erreur adapte autorise ?
- si ss, sencée executer sa quand sb impossible ?

correc 
https://github.com/caecitasminimus/school21-checklists

etapes :
algo de tri
--
bonus




comp
make && ARG="1 2 3 4 5" valgrind --leak-check=full --track-origins=yes ./push_swap $ARG | ./checker $ARG && ./push_swap $ARG | wc -l

make && valgrind --leak-check=full --track-origins=yes ./push_swap "5 2 6 9 +66661"
gcc -Wall -Wextra -Werror -g3 -fsanitize=address
make && valgrind --leak-check=full --track-origins=yes ./push_swap 5 2 6 +94564 55 -9 -3 12 -2 0
make && valgrind --leak-check=full --track-origins=yes ./push_swap 5 2 6 +94564 55 -9 -3 12 -2 13 16 59 75 96 100 41 36 22 11 66 -78

ressources interessantes :
https://www.calculatorsoup.com/calculators/statistics/random-number-generator.php
https://github.com/AdrianWR/push_swap
https://medium.com/@jamierobertdawson/push-swap-the-least-amount-of-moves-with-two-stacks-d1e76a71789a

radix sort ; attention aux negatifs lors de la lecture binaire
ruby -e "puts (1..100).to_a.shuffle"
ARG="1 2 3" | ./push_swap $=ARG   (ajouter = pour eviter conflits sous zsh)

push b le plus petit nb puis adapter à partir de là
 grps de 3
diviser par deux
ecart min et max
opti en essayant d'utiliser tous les moves


quand push sur b rb si > median

50         9 7coup
100        48 4 
1           
            69 5

ra rb 
rra rrb
ra rrb
rra rb

1 arg ou stack triee affiche rien
8 moves max si 5
3 moves max si 3
<700 pour 100
<5500 pour 500


push tout dans b sauf min max et median
ensuite stocker nb de coup optimal pour trier head de b
comparer nb de coup du nb a trier dans les *nb de coup* prochain next de b
pusha l'opti et trier a en optimisant le nb de coup : 8 ra et 6 rb == 6rr et 2ra 
recommencer

ajouter error dans struct desormais pour faciliter gestion erreur
exit success au lieu de remonter en cas derreur?


next:
corriger le get index dans readhead
transposerdans readtail
algo
nb de ra a modifier selon next tri
ou
ne pas boucle ra, mais calculer place next move selon index dans actual a

make && ./push_swap "-47 -43 25 53 -67 7 -83 12 2 28 -95 -27 -68 -97 95 31 -31 43 -52 1 -26 -96 -20 79 85 6 78 -3 -8 -24 -55 -78 63 -75 68 -41 20 16 -14 70 96 -64 -60 64 -82 86 -69 17 40 -77 67 75 -23 -36 88 56 39 41 51 94 19 93 -100 -11 48 61 8 -33 -6 -29 59 -87 -22 -72 24 -80 11 18 35 87 -61 10 -89 -42 50 46 -73 84 -44 5 47 58 -66 13 -92 29 -17 45 4 -71