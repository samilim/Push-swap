questions :
- argument str ou pas ?
- gerer les espaces en trop ?
- cas int un seul nb erreur?
- message erreur adapte autorise ?
- si ss, sencée executer sa quand sb impossible ?

correc 
https://github.com/caecitasminimus/school21-checklists

etapes :
algo de tri
--
bonus




comp
make && ARG="48 -51 62 89 54 50 -80 37 -78 64 97 -72 65 76 -74 -21 -64 43 33 -34 88 57 91 -18 -25 -8 11 41 -58 -69 -43 0 -95 14 17 -81 42 49 -15 -40 -55 -70 -76 7 -92 -22 -47 -54 -33 30 26 -79 -13 -37 -7 -99 21 -94 10 -84 29 24 -32 -38 13 -30 47 -28 -52 52 -4 85 28 -67 -63 84 -71 19 70 -96 83 99 -31 73 9 12 -62 53 -35 92 -45 72 -97 90 -5 45 -44 100 -42 -41" valgrind --leak-check=full --track-origins=yes ./push_swap $ARG | ./checker $ARG && ./push_swap $ARG | wc -l

make && valgrind --leak-check=full --track-origins=yes ./push_swap "5 2 6 9 +66661"
gcc -Wall -Wextra -Werror -g3 -fsanitize=address
make && valgrind --leak-check=full --track-origins=yes ./push_swap 5 2 6 +94564 55 -9 -3 12 -2 0
make && valgrind --leak-check=full --track-origins=yes ./push_swap 5 2 6 +94564 55 -9 -3 12 -2 13 16 59 75 96 100 41 36 22 11 66 -78

make && ARG="88 -98 39 -33 -67 20 -18 64 73 -91 58 -8 91 14 3 -14 -51 -79 70 85 -19 13 -10 -21 15 -49 -2 56 78 98 30 12 -65 -63 -1 -4 -47 -5 -89 36 2 -29 -57 -35 9 -39 -50 17 97 26 68 46 -24 -52 10 -31 4 92 67 81 5 -32 37 -12 -59 99 -97 -16 -100 -43 50 -86 35 -9 -36 19 71 -68 29 -40 32 84 -93 90 72 -37 -87 -30 -25 -42 43 45 63 -90 48 1 86 -88 -92 47" valgrind --leak-check=full --track-origins=yes ./push_swap $ARG | ./checker $ARG && ./push_swap $ARG | wc -l

ressources interessantes :
https://www.calculatorsoup.com/calculators/statistics/random-number-generator.php
https://github.com/AdrianWR/push_swap
https://medium.com/@jamierobertdawson/push-swap-the-least-amount-of-moves-with-two-stacks-d1e76a71789a

radix sort ; attention aux negatifs lors de la lecture binaire
ruby -e "puts (1..100).to_a.shuffle"
ARG="1 2 3" | ./push_swap $=ARG   (ajouter = pour eviter conflits sous zsh)

push b le plus petit nb puis adapter à partir de là
 grps de 3
diviser par deux
ecart min et max
opti en essayant d'utiliser tous les moves


quand push sur b rb si > median

50         9 7coup
100        48 4 
1           
            69 5

ra rb 
rra rrb
ra rrb
rra rb

1 arg ou stack triee affiche rien
8 moves max si 5
3 moves max si 3
<700 pour 100
<5500 pour 500


push tout dans b sauf min max et median
ensuite stocker nb de coup optimal pour trier head de b
comparer nb de coup du nb a trier dans les *nb de coup* prochain next de b
pusha l'opti et trier a en optimisant le nb de coup : 8 ra et 6 rb == 6rr et 2ra 
recommencer

ajouter error dans struct desormais pour faciliter gestion erreur
exit success au lieu de remonter en cas derreur?


next:
rotate/reverse avant pa


corriger le get index dans readhead
transposerdans readtail
algo
nb de ra a modifier selon next tri
ou
ne pas boucle ra, mais calculer place next move selon index dans actual a

make && ./push_swap "-47 -43 25 53 -67 7 -83 12 2 28 -95 -27 -68 -97 95 31 -31 43 -52 1 -26 -96 -20 79 85 6 78 -3 -8 -24 -55 -78 63 -75 68 -41 20 16 -14 70 96 -64 -60 64 -82 86 -69 17 40 -77 67 75 -23 -36 88 56 39 41 51 94 19 93 -100 -11 48 61 8 -33 -6 -29 59 -87 -22 -72 24 -80 11 18 35 87 -61 10 -89 -42 50 46 -73 84 -44 5 47 58 -66 13 -92 29 -17 45 4 -71