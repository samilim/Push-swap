questions :
- argument str ou pas ?
- gerer les espaces en trop ?
- cas int un seul nb erreur?
- message erreur adapte autorise ?
- si ss, sencée executer sa quand sb impossible ?

correc 
https://github.com/caecitasminimus/school21-checklists

etapes :
algo de tri
--
bonus




comp
make && ARG="1 2 3 4 5" valgrind --leak-check=full --track-origins=yes ./push_swap $ARG | ./checker $ARG && ./push_swap $ARG | wc -l

make && valgrind --leak-check=full --track-origins=yes ./push_swap "5 2 6 9 +66661"
gcc -Wall -Wextra -Werror -g3 -fsanitize=address
make && valgrind --leak-check=full --track-origins=yes ./push_swap 5 2 6 +94564 55 -9 -3 12 -2 0
make && valgrind --leak-check=full --track-origins=yes ./push_swap 5 2 6 +94564 55 -9 -3 12 -2 13 16 59 75 96 100 41 36 22 11 66 -78

ressources interessantes :
https://www.calculatorsoup.com/calculators/statistics/random-number-generator.php
https://github.com/AdrianWR/push_swap
https://medium.com/@jamierobertdawson/push-swap-the-least-amount-of-moves-with-two-stacks-d1e76a71789a

radix sort ; attention aux negatifs lors de la lecture binaire
ruby -e "puts (1..100).to_a.shuffle"
ARG="1 2 3" | ./push_swap $=ARG   (ajouter = pour eviter conflits sous zsh)

push b le plus petit nb puis adapter à partir de là
 grps de 3
diviser par deux
ecart min et max
opti en essayant d'utiliser tous les moves


quand push sur b rb si > median

50         9 7coup
100        48 4 
1           
            69 5

ra rb 
rra rrb
ra rrb
rra rb

1 arg ou stack triee affiche rien
8 moves max si 5
3 moves max si 3
<700 pour 100
<5500 pour 500


push tout dans b sauf min max et median
ensuite stocker nb de coup optimal pour trier head de b
comparer nb de coup du nb a trier dans les *nb de coup* prochain next de b
pusha l'opti et trier a en optimisant le nb de coup : 8 ra et 6 rb == 6rr et 2ra 
recommencer

ajouter error dans struct desormais pour faciliter gestion erreur
exit success au lieu de remonter en cas derreur?